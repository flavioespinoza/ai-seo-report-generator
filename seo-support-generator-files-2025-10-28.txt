===== src/app/layout.tsx =====
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import '@/styles/globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
	title: 'SEO Report Generator - AI-Powered Website Analysis',
	description: 'Generate comprehensive SEO reports for any website using AI-powered analysis'
}

export default function RootLayout({ children }: { children: React.ReactNode }) {
	return (
		<html lang="en">
			<body className={inter.className}>{children}</body>
		</html>
	)
}
===== src/app/api/analyze/route.ts =====
import { NextRequest, NextResponse } from 'next/server'
import { dbOperations } from '@/lib/db'
import { generateSeoFeedback } from '@/lib/openai'
import { ScraperError, scrapeMetadata } from '@/lib/scraper'
import { z } from 'zod'

const analyzeSchema = z.object({
	url: z.string().url('Please provide a valid URL')
})

export async function POST(request: NextRequest) {
	try {
		const body = await request.json()

		const validation = analyzeSchema.safeParse(body)
		if (!validation.success) {
			return NextResponse.json({ error: validation.error.errors[0].message }, { status: 400 })
		}

		const { url } = validation.data

		let metadata
		try {
			metadata = await scrapeMetadata(url)
		} catch (error) {
			if (error instanceof ScraperError) {
				return NextResponse.json({ error: error.message }, { status: error.statusCode || 400 })
			}
			throw error
		}

		const aiFeedback = await generateSeoFeedback(metadata)

		const reportId = dbOperations.createReport({
			url: metadata.url,
			page_title: metadata.pageTitle,
			meta_description: metadata.metaDescription,
			meta_keywords: metadata.metaKeywords,
			h1_tags: metadata.h1Tags.join(' | '),
			image_count: metadata.imageCount,
			has_favicon: metadata.hasFavicon ? 1 : 0,
			ai_feedback: aiFeedback
		})

		const report = dbOperations.getReportById(Number(reportId))

		return NextResponse.json({
			success: true,
			report: {
				id: report?.id,
				url: report?.url,
				metadata: {
					pageTitle: metadata.pageTitle,
					metaDescription: metadata.metaDescription,
					metaKeywords: metadata.metaKeywords,
					h1Tags: metadata.h1Tags,
					imageCount: metadata.imageCount,
					hasFavicon: metadata.hasFavicon,
					titleLength: metadata.titleLength,
					descriptionLength: metadata.descriptionLength
				},
				aiFeedback,
				createdAt: report?.created_at
			}
		})
	} catch (error) {
		console.error('Analysis error:', error)

		return NextResponse.json(
			{
				error:
					error instanceof Error ? error.message : 'Failed to analyze website. Please try again.'
			},
			{ status: 500 }
		)
	}
}
===== src/app/api/reports/ route.ts =====
===== src/app/api/reports/route.ts =====
import { NextRequest, NextResponse } from 'next/server'
import { dbOperations } from '@/lib/db'

export async function GET(request: NextRequest) {
	try {
		const searchParams = request.nextUrl.searchParams
		const url = searchParams.get('url')
		const limit = parseInt(searchParams.get('limit') || '50')

		let reports

		if (url) {
			reports = dbOperations.getReportsByUrl(url)
		} else {
			reports = dbOperations.getAllReports(limit)
		}

		const transformedReports = reports.map((report) => ({
			id: report.id,
			url: report.url,
			pageTitle: report.page_title,
			metaDescription: report.meta_description,
			createdAt: report.created_at,
			hasIssues: !report.page_title || !report.meta_description
		}))

		return NextResponse.json({
			success: true,
			reports: transformedReports,
			count: transformedReports.length
		})
	} catch (error) {
		console.error('Fetch reports error:', error)

		return NextResponse.json({ error: 'Failed to fetch reports' }, { status: 500 })
	}
}
===== src/app/api/reports/[id]/route.ts =====
import { NextRequest, NextResponse } from 'next/server';
import { dbOperations } from '@/lib/db';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id);
    
    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'Invalid report ID' },
        { status: 400 }
      );
    }

    const report = dbOperations.getReportById(id);

    if (!report) {
      return NextResponse.json(
        { error: 'Report not found' },
        { status: 404 }
      );
    }

    const transformedReport = {
      id: report.id,
      url: report.url,
      metadata: {
        pageTitle: report.page_title,
        metaDescription: report.meta_description,
        metaKeywords: report.meta_keywords,
        h1Tags: report.h1_tags?.split(' | ') || [],
        imageCount: report.image_count,
        hasFavicon: report.has_favicon === 1,
      },
      aiFeedback: report.ai_feedback,
      createdAt: report.created_at,
    };

    return NextResponse.json({
      success: true,
      report: transformedReport,
    });
  } catch (error) {
    console.error('Fetch report error:', error);
    
    return NextResponse.json(
      { error: 'Failed to fetch report' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = parseInt(params.id);
    
    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'Invalid report ID' },
        { status: 400 }
      );
    }

    dbOperations.deleteReport(id);

    return NextResponse.json({
      success: true,
      message: 'Report deleted successfully',
    });
  } catch (error) {
    console.error('Delete report error:', error);
    
    return NextResponse.json(
      { error: 'Failed to delete report' },
      { status: 500 }
    );
  }
}
===== src/app/page.tsx =====
'use client'

import { useEffect, useState } from 'react'
import ErrorAlert from '@/components/ErrorAlert'
import ReportHistory from '@/components/ReportHistory'
import SeoReport from '@/components/SeoReport'
import UrlInputForm from '@/components/UrlInputForm'
import MarkdownWithCode from '@/components/markdown-with-code'

interface Report {
	id?: number
	url: string
	metadata: {
		pageTitle: string | null
		metaDescription: string | null
		metaKeywords: string | null
		h1Tags: string[]
		imageCount: number
		hasFavicon: boolean
		titleLength?: number
		descriptionLength?: number
	}
	aiFeedback: string
	createdAt?: string
}

interface ReportSummary {
	id: number
	url: string
	pageTitle: string | null
	metaDescription: string | null
	createdAt: string
	hasIssues: boolean
}

export default function Home() {
	const [loading, setLoading] = useState(false)
	const [error, setError] = useState<string | null>(null)
	const [currentReport, setCurrentReport] = useState<Report | null>(null)
	const [reportHistory, setReportHistory] = useState<ReportSummary[]>([])
	const [historyLoading, setHistoryLoading] = useState(true)

	useEffect(() => {
		fetchReportHistory()
	}, [])

	const fetchReportHistory = async () => {
		try {
			setHistoryLoading(true)
			const response = await fetch('/api/reports')
			const data = await response.json()

			if (data.success) {
				setReportHistory(data.reports)
			}
		} catch (err) {
			console.error('Failed to fetch report history:', err)
		} finally {
			setHistoryLoading(false)
		}
	}

	const handleAnalyze = async (url: string) => {
		setLoading(true)
		setError(null)
		setCurrentReport(null)

		try {
			const response = await fetch('/api/analyze', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({ url })
			})

			const data = await response.json()

			if (!response.ok) {
				throw new Error(data.error || 'Failed to analyze website')
			}

			if (data.success && data.report) {
				setCurrentReport(data.report)
				await fetchReportHistory()
			}
		} catch (err) {
			setError(err instanceof Error ? err.message : 'An unexpected error occurred')
		} finally {
			setLoading(false)
		}
	}

	const handleSelectReport = async (id: number) => {
		try {
			const response = await fetch(`/api/reports/${id}`)
			const data = await response.json()

			if (data.success && data.report) {
				setCurrentReport(data.report)
				setError(null)
			}
		} catch (err) {
			setError('Failed to load report')
		}
	}

	const handleDeleteReport = async (id: number) => {
		try {
			const response = await fetch(`/api/reports/${id}`, {
				method: 'DELETE'
			})

			if (response.ok) {
				if (currentReport?.id === id) {
					setCurrentReport(null)
				}
				await fetchReportHistory()
			}
		} catch (err) {
			setError('Failed to delete report')
		}
	}

	const handleExportReport = () => {
		if (!currentReport) return

		return generateHTMLReport(currentReport)
		// const blob = new Blob([markdown], { type: 'text/markdown' })
		// const url = URL.createObjectURL(blob)
		// const a = document.createElement('a')
		// a.href = url
		// a.download = `seo-report-${Date.now()}.md`
		// document.body.appendChild(a)
		// a.click()
		// document.body.removeChild(a)
		// URL.revokeObjectURL(url)
	}

	// Define the structure of the report
	const generateHTMLReport = (report: Report) => {
		const { metadata, aiFeedback, url, createdAt } = report

		if (typeof report === 'string') {
			return <div style={{ background: 'hotpink'}}>
				<MarkdownWithCode markdown={report} />
			</div>
		} else {
			return 'Something went wrong with the report.'
		}
	}

	return (
		<main className="min-h-screen px-4 py-12 sm:px-6 lg:px-8">
			<div className="mx-auto max-w-3xl">
				<div className="mb-12 text-center">
					<h1 className="text-gray-900 mb-3 text-4xl font-bold">SEO Report Generator</h1>
					<p className="text-gray-600 text-lg">
						AI-powered website analysis to improve your search engine optimization
					</p>
				</div>

				<div className="mb-8">
					<UrlInputForm onAnalyze={handleAnalyze} loading={loading} />
				</div>

				{error && (
					<div className="mb-8">
						<ErrorAlert message={error} onDismiss={() => setError(null)} />
					</div>
				)}

				{currentReport && (
					<div className="mb-8">
						<SeoReport report={currentReport} onExport={handleExportReport} />
					</div>
				)}

				<div className="mx-auto max-w-3xl">
					<ReportHistory
						reports={reportHistory}
						onSelectReport={handleSelectReport}
						onDeleteReport={handleDeleteReport}
						loading={historyLoading}
					/>
				</div>

				<footer className="text-gray-500 mt-16 text-center text-sm">
					<p>Built with Next.js, TypeScript, and OpenAI</p>
				</footer>
			</div>
		</main>
	)
}
===== src/components/ReportHistory.tsx =====
import React from 'react'

interface ReportSummary {
	id: number
	url: string
	pageTitle: string | null
	metaDescription: string | null
	createdAt: string
	hasIssues: boolean
}

interface ReportHistoryProps {
	reports: ReportSummary[]
	onSelectReport: (id: number) => void
	onDeleteReport: (id: number) => void
	loading?: boolean
}

export default function ReportHistory({
	reports,
	onSelectReport,
	onDeleteReport,
	loading = false
}: ReportHistoryProps) {
	if (loading) {
		return (
			<div className="rounded-lg bg-white p-6 shadow-md">
				<h3 className="text-gray-900 mb-4 text-xl font-semibold">Report History</h3>
				<div className="flex justify-center py-8">
					<svg className="h-8 w-8 animate-spin text-blue-600" viewBox="0 0 24 24">
						<circle
							className="opacity-25"
							cx="12"
							cy="12"
							r="10"
							stroke="currentColor"
							strokeWidth="4"
							fill="none"
						/>
						<path
							className="opacity-75"
							fill="currentColor"
							d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
						/>
					</svg>
				</div>
			</div>
		)
	}

	if (reports.length === 0) {
		return (
			<div className="rounded-lg bg-white p-6 shadow-md">
				<h3 className="text-gray-900 mb-4 text-xl font-semibold">Report History</h3>
				<div className="text-gray-500 py-8 text-center">
					<svg
						className="text-gray-400 mx-auto mb-3 h-12 w-12"
						fill="none"
						viewBox="0 0 24 24"
						stroke="currentColor"
					>
						<path
							strokeLinecap="round"
							strokeLinejoin="round"
							strokeWidth={2}
							d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
						/>
					</svg>
					<p>No reports yet</p>
					<p className="mt-1 text-sm">Analyze a website to create your first report</p>
				</div>
			</div>
		)
	}

	return (
		<div className="rounded-lg bg-white p-6 shadow-md">
			<h3 className="text-gray-900 mb-4 text-xl font-semibold">
				Report History
				<span className="text-gray-500 ml-2 text-sm font-normal">
					({reports.length} {reports.length === 1 ? 'report' : 'reports'})
				</span>
			</h3>
			<div className="space-y-3">
				{reports.map((report) => (
					<div
						key={report.id}
						className="border-gray-200 group rounded-lg border p-4 transition hover:border-blue-300"
					>
						<div className="flex items-start justify-between gap-4">
							<button onClick={() => onSelectReport(report.id)} className="flex-1 text-left">
								<div className="mb-1 flex items-center gap-2">
									<h4 className="text-gray-900 font-medium transition group-hover:text-blue-600">
										{report.pageTitle || 'Untitled Page'}
									</h4>
									{report.hasIssues && (
										<span className="inline-flex items-center rounded bg-yellow-100 px-2 py-0.5 text-xs font-medium text-yellow-800">
											Issues Found
										</span>
									)}
								</div>
								<p className="text-gray-600 truncate text-sm">{report.url}</p>
								<p className="text-gray-500 mt-1 text-xs">
									{new Date(report.createdAt).toLocaleString()}
								</p>
							</button>
							<button
								onClick={(e) => {
									e.stopPropagation()
									if (confirm('Are you sure you want to delete this report?')) {
										onDeleteReport(report.id)
									}
								}}
								className="text-gray-400 p-1 transition hover:text-red-600"
								title="Delete report"
							>
								<svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
									<path
										strokeLinecap="round"
										strokeLinejoin="round"
										strokeWidth={2}
										d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
									/>
								</svg>
							</button>
						</div>
					</div>
				))}
			</div>
		</div>
	)
}
===== src/components/Icon.tsx =====
import React from 'react'



export default function Icon() {

  return (
    <div>Icon</div>
  )
}
===== src/components/markdown-with-code.tsx =====
'use client'

import React, { useState } from 'react'
import ReactMarkdown from 'react-markdown'
import { Prism as SyntaxHighlighterBase } from 'react-syntax-highlighter'
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism'
import { Button } from '@flavioespinoza/salsa-ui'
import { Check, Copy } from 'lucide-react'

interface MarkdownWithCodeProps {
	markdown: string
}

const MarkdownWithCode: React.FC<MarkdownWithCodeProps> = ({ markdown }) => {
	const CodeBlock = ({ node, inline, className, children, ...props }: any): JSX.Element => {
		const match = /language-(\w+)/.exec(className || '')
		const language = match ? match[1] : null
		const [copied, setCopied] = useState(false)

		const handleCopy = () => {
			navigator.clipboard.writeText(String(children)).then(() => {
				setCopied(true)
				setTimeout(() => setCopied(false), 4000)
			})
		}

		const SyntaxHighlighter = SyntaxHighlighterBase as unknown as React.ComponentType<any>

		if (!inline && language) {
			return (
				<div className="overflow-hidden rounded-md border border-zinc-200">
					<div className="flex items-center justify-between bg-sage-600 px-3 font-mono text-[10px] text-white">
						<span>{language}</span>
						<Button variant="static" size="sm" className="p-0" onClick={handleCopy}>
							{copied ? (
								<div className="flex">
									<Check className="h-3.5 w-3 text-white" />
									<div className="ml-1 text-[10px] text-white">Copied</div>
								</div>
							) : (
								<div className="flex">
									<Copy className="h-3.5 w-3 text-white" />
									<div className="ml-1 text-[10px] text-white">Copy</div>
								</div>
							)}
						</Button>
					</div>
					<SyntaxHighlighter
						style={vscDarkPlus}
						language={language}
						PreTag="div"
						customStyle={{
							margin: 0,
							padding: '1rem',
							fontSize: '0.875rem'
						}}
						{...props}
					>
						<div id="parent">{String(children).replace(/\n$/, '')}</div>
					</SyntaxHighlighter>
				</div>
			)
		}

		return (
			<code className={className} {...props}>
				{children}
			</code>
		)
	}

	return (
		<div className="markdown-parent-element">
			<ReactMarkdown
				components={{
					code: CodeBlock
				}}
			>
				{markdown}
			</ReactMarkdown>
		</div>
	)
}

export default MarkdownWithCode
===== src/components/UrlInputForm.tsx =====
import React, { useState } from 'react'

interface UrlInputFormProps {
	onAnalyze: (url: string) => void
	loading: boolean
}

export default function UrlInputForm({ onAnalyze, loading }: UrlInputFormProps) {
	const [url, setUrl] = useState('')
	const [error, setError] = useState('')

	const handleSubmit = (e: React.FormEvent) => {
		e.preventDefault()
		setError('')

		if (!url.trim()) {
			setError('Please enter a URL')
			return
		}

		try {
			new URL(url.startsWith('http') ? url : `https://${url}`)
			onAnalyze(url)
		} catch {
			setError('Please enter a valid URL')
		}
	}

	return (
		<form onSubmit={handleSubmit} className="mx-auto w-full max-w-3xl">
			<div className="rounded-lg bg-white p-6 shadow-md">
				<label htmlFor="url-input" className="text-gray-700 mb-2 block text-sm font-medium">
					Website URL
				</label>
				<div className="flex gap-3">
					<input
						id="url-input"
						type="text"
						value={url}
						onChange={(e) => {
							setUrl(e.target.value)
							setError('')
						}}
						placeholder="https://example.com or example.com"
						className="border-gray-300 flex-1 rounded-lg border px-4 py-3 outline-none transition focus:border-transparent focus:ring-2 focus:ring-blue-500"
						disabled={loading}
					/>
					<button
						type="submit"
						disabled={loading}
						className="rounded-lg bg-blue-600 px-6 py-3 font-medium text-white transition hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
					>
						{loading ? (
							<span className="flex items-center gap-2">
								<svg className="h-5 w-5 animate-spin" viewBox="0 0 24 24">
									<circle
										className="opacity-25"
										cx="12"
										cy="12"
										r="10"
										stroke="currentColor"
										strokeWidth="4"
										fill="none"
									/>
									<path
										className="opacity-75"
										fill="currentColor"
										d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
									/>
								</svg>
								Analyzing...
							</span>
						) : (
							'Analyze SEO'
						)}
					</button>
				</div>
				{error && <p className="mt-2 text-sm text-red-600">{error}</p>}
				<p className="text-gray-500 mt-3 text-sm">
					Enter any website URL to receive a comprehensive SEO analysis powered by AI
				</p>
			</div>
		</form>
	)
}
===== src/components/ErrorAlert.tsx =====
import React from 'react';
import * as Dialog from '@radix-ui/react-dialog';
import { Button } from '@flavioespinoza/salsa-ui';
import { AlertCircle, X } from 'lucide-react';

interface ErrorAlertProps {
  message: string;
  onDismiss?: () => void;
}

export default function ErrorAlert({ message, onDismiss }: ErrorAlertProps) {
  const [open, setOpen] = React.useState(true);

  const handleOpenChange = (isOpen: boolean) => {
    setOpen(isOpen);
    if (!isOpen && onDismiss) {
      onDismiss();
    }
  };

  return (
    <Dialog.Root open={open} onOpenChange={handleOpenChange}>
      <Dialog.Portal>
        <Dialog.Overlay className="fixed inset-0 bg-black/50" />
        <Dialog.Content className="fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-full max-w-md">
          <div className="p-6 bg-red-100">
            <div className="flex items-start justify-between gap-4">
              <div className="flex items-center gap-3">
                <AlertCircle className="h-6 w-6 text-red-600 flex-shrink-0" />
                <Dialog.Title className="text-lg font-semibold text-red-600">
                  Error
                </Dialog.Title>
              </div>
              <Dialog.Close className="text-gray-400 hover:text-red-600 transition flex-shrink-0">
                <X className="h-5 w-5 text-red-600" />
              </Dialog.Close>
            </div>

            {/* Wrapped message in scrollable div */}
            <Dialog.Description className="mt-4 text-sm text-red-600">
              <div className="overflow-hidden">
								{message}
              </div>
            </Dialog.Description>

            <div className="mt-6 flex justify-end">
              <Dialog.Close asChild>
                <Button variant="default" className="bg-red-600">
                  Close
                </Button>
              </Dialog.Close>
            </div>
          </div>
        </Dialog.Content>
      </Dialog.Portal>
    </Dialog.Root>
  );
}
===== src/components/SeoReport.tsx =====
import React from 'react'
import MarkdownWithCode from './markdown-with-code'

interface Metadata {
	pageTitle: string | null
	metaDescription: string | null
	metaKeywords: string | null
	h1Tags: string[]
	imageCount: number
	hasFavicon: boolean
	titleLength?: number
	descriptionLength?: number
}

interface SeoReportProps {
	report: {
		id?: number
		url: string
		metadata: Metadata
		aiFeedback: string
		createdAt?: string
	}
	onExport?: () => void
}

export default function SeoReport({ report, onExport }: SeoReportProps) {
	const { metadata, aiFeedback, url, createdAt } = report

	const getStatusColor = (hasValue: boolean) => {
		return hasValue ? 'text-green-600' : 'text-red-600'
	}

	const getStatusIcon = (hasValue: boolean) => {
		return hasValue ? '✓' : '✗'
	}

	return (
		<div className="mx-auto w-full max-w-5xl space-y-6">
			<div className="rounded-lg bg-white p-6 shadow-md">
				<div className="mb-4 flex items-start justify-between">
					<div className="flex-1">
						<h2 className="text-gray-900 mb-2 text-2xl font-bold">SEO Analysis Report</h2>
						<a
							href={url}
							target="_blank"
							rel="noopener noreferrer"
							className="break-all text-blue-600 hover:underline"
						>
							{url}
						</a>
						{createdAt && (
							<p className="text-gray-500 mt-2 text-sm">
								Generated: {new Date(createdAt).toLocaleString()}
							</p>
						)}
					</div>
					{onExport && (
						<button
							onClick={onExport}
							className="bg-gray-100 text-gray-700 hover:bg-gray-200 rounded-lg px-4 py-2 text-sm font-medium transition"
						>
							Export Report
						</button>
					)}
				</div>
			</div>

			<div className="rounded-lg bg-white p-6 shadow-md">
				<h3 className="text-gray-900 mb-4 text-xl font-semibold">Page Metadata</h3>
				<div className="space-y-4">
					<div>
						<div className="mb-1 flex items-center gap-2">
							<span className={`font-medium ${getStatusColor(!!metadata.pageTitle)}`}>
								{getStatusIcon(!!metadata.pageTitle)}
							</span>
							<span className="text-gray-700 font-medium">Page Title</span>
							{metadata.titleLength && (
								<span className="text-gray-500 text-sm">({metadata.titleLength} characters)</span>
							)}
						</div>
						<p className="text-gray-600 ml-6">{metadata.pageTitle || 'No title found'}</p>
					</div>

					<div>
						<div className="mb-1 flex items-center gap-2">
							<span className={`font-medium ${getStatusColor(!!metadata.metaDescription)}`}>
								{getStatusIcon(!!metadata.metaDescription)}
							</span>
							<span className="text-gray-700 font-medium">Meta Description</span>
							{metadata.descriptionLength && (
								<span className="text-gray-500 text-sm">
									({metadata.descriptionLength} characters)
								</span>
							)}
						</div>
						<p className="text-gray-600 ml-6">
							{metadata.metaDescription || 'No description found'}
						</p>
					</div>

					<div>
						<div className="mb-1 flex items-center gap-2">
							<span className={`font-medium ${getStatusColor(metadata.h1Tags.length > 0)}`}>
								{getStatusIcon(metadata.h1Tags.length > 0)}
							</span>
							<span className="text-gray-700 font-medium">H1 Tags</span>
							<span className="text-gray-500 text-sm">({metadata.h1Tags.length} found)</span>
						</div>
						{metadata.h1Tags.length > 0 ? (
							<ul className="ml-6 space-y-1">
								{metadata.h1Tags.map((tag, index) => (
									<li key={index} className="text-gray-600">
										• {tag}
									</li>
								))}
							</ul>
						) : (
							<p className="text-gray-600 ml-6">No H1 tags found</p>
						)}
					</div>

					<div className="grid grid-cols-2 gap-4 pt-2">
						<div>
							<span className="text-gray-700 font-medium">Images: </span>
							<span className="text-gray-600">{metadata.imageCount}</span>
						</div>
						<div>
							<span className="text-gray-700 font-medium">Favicon: </span>
							<span className={getStatusColor(metadata.hasFavicon)}>
								{metadata.hasFavicon ? 'Present' : 'Missing'}
							</span>
						</div>
					</div>
				</div>
			</div>

			<div className="rounded-lg bg-white p-6 shadow-md">
				<h3 className="text-gray-900 mb-4 text-xl font-semibold">AI-Powered SEO Analysis</h3>
				<div className="prose max-w-none">
					<div id="parent" className="">
						<MarkdownWithCode markdown={aiFeedback} />
					</div>
				</div>
			</div>
		</div>
	)
}
===== src/lib/openai.ts =====
import OpenAI from 'openai'
import { PageMetadata, validateMetadata } from './scraper'

console.log(process.env.OPENAI_API_KEY)

const openai = new OpenAI({
	apiKey: process.env.OPENAI_API_KEY
})

export interface SeoAnalysis {
	summary: string
	strengths: string[]
	improvements: string[]
	technicalIssues: string[]
	recommendations: string[]
}

export async function generateSeoFeedback(metadata: PageMetadata): Promise<string> {
	const { issues, warnings } = validateMetadata(metadata)

	const prompt = `You are an expert SEO consultant. Analyze the following webpage metadata and provide actionable SEO improvement recommendations.

Website URL: ${metadata.url}

Metadata:
- Page Title: ${metadata.pageTitle || 'MISSING'}
- Title Length: ${metadata.titleLength} characters
- Meta Description: ${metadata.metaDescription || 'MISSING'}
- Description Length: ${metadata.descriptionLength} characters
- Meta Keywords: ${metadata.metaKeywords || 'Not specified'}
- H1 Tags: ${metadata.h1Tags.length > 0 ? metadata.h1Tags.join(', ') : 'NONE FOUND'}
- Number of Images: ${metadata.imageCount}
- Has Favicon: ${metadata.hasFavicon ? 'Yes' : 'No'}

Automated Issues Detected:
${issues.length > 0 ? issues.map((i) => `- ${i}`).join('\n') : '- None'}

Automated Warnings:
${warnings.length > 0 ? warnings.map((w) => `- ${w}`).join('\n') : '- None'}

Please provide:
1. A brief overall SEO health summary (2-3 sentences)
2. Key strengths (if any)
3. Critical improvements needed
4. Technical SEO issues
5. Specific, actionable recommendations

Format your response in clear sections with bullet points where appropriate. Be specific and practical.`

	try {
		const response = await openai.chat.completions.create({
			model: 'gpt-4o-mini',
			messages: [
				{
					role: 'system',
					content:
						'You are an expert SEO consultant providing clear, actionable advice. Focus on practical improvements that will have the most impact.'
				},
				{
					role: 'user',
					content: prompt
				}
			],
			temperature: 0.7,
			max_tokens: 1000
		})

		const feedback = response.choices[0]?.message?.content

		if (!feedback) {
			throw new Error('No feedback generated from OpenAI')
		}

		return feedback
	} catch (error) {
		if (error instanceof Error) {
			throw new Error(`OpenAI API error: ${error.message}`)
		}
		throw new Error('Failed to generate SEO feedback')
	}
}

export function parseSeoFeedback(feedback: string): SeoAnalysis {
	const lines = feedback.split('\n')
	const analysis: SeoAnalysis = {
		summary: '',
		strengths: [],
		improvements: [],
		technicalIssues: [],
		recommendations: []
	}

	let currentSection: keyof SeoAnalysis | null = null
	let summaryLines: string[] = []

	for (const line of lines) {
		const trimmed = line.trim()

		if (!trimmed) continue

		if (trimmed.toLowerCase().includes('summary') || trimmed.toLowerCase().includes('overall')) {
			currentSection = 'summary'
			continue
		} else if (trimmed.toLowerCase().includes('strength')) {
			currentSection = 'strengths'
			continue
		} else if (
			trimmed.toLowerCase().includes('improvement') ||
			trimmed.toLowerCase().includes('critical')
		) {
			currentSection = 'improvements'
			continue
		} else if (trimmed.toLowerCase().includes('technical')) {
			currentSection = 'technicalIssues'
			continue
		} else if (trimmed.toLowerCase().includes('recommendation')) {
			currentSection = 'recommendations'
			continue
		}

		if (currentSection === 'summary') {
			if (!trimmed.startsWith('-') && !trimmed.startsWith('*') && !trimmed.match(/^\d+\./)) {
				summaryLines.push(trimmed)
			}
		} else if (
			currentSection !== null &&
			(trimmed.startsWith('-') || trimmed.startsWith('*') || trimmed.match(/^\d+\./))
		) {
			const content = trimmed
				.replace(/^[-*]\s*/, '')
				.replace(/^\d+\.\s*/, '')
				.trim()
			if (content) {
				analysis[currentSection].push(content)
			}
		}
	}

	analysis.summary = summaryLines.join(' ').trim()

	return analysis
}
===== src/lib/db.ts =====
import Database from 'better-sqlite3'
import { existsSync, mkdirSync } from 'fs'
import { join } from 'path'

const DB_PATH = process.env.DATABASE_PATH || './data/seo-reports.db'
const DB_DIR = join(process.cwd(), 'data')

if (!existsSync(DB_DIR)) {
	mkdirSync(DB_DIR, { recursive: true })
}

const db = new Database(join(process.cwd(), DB_PATH))

db.pragma('foreign_keys = ON')

db.exec(`
  CREATE TABLE IF NOT EXISTS seo_reports (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    url TEXT NOT NULL,
    page_title TEXT,
    meta_description TEXT,
    meta_keywords TEXT,
    h1_tags TEXT,
    image_count INTEGER DEFAULT 0,
    has_favicon INTEGER DEFAULT 0,
    ai_feedback TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  );

  CREATE INDEX IF NOT EXISTS idx_url ON seo_reports(url);
  CREATE INDEX IF NOT EXISTS idx_created_at ON seo_reports(created_at);
`)

export interface SeoReport {
	id?: number
	url: string
	page_title: string | null
	meta_description: string | null
	meta_keywords: string | null
	h1_tags: string | null
	image_count: number
	has_favicon: number
	ai_feedback: string
	created_at?: string
}

export const dbOperations = {
	createReport: (report: Omit<SeoReport, 'id' | 'created_at'>) => {
		const stmt = db.prepare(`
      INSERT INTO seo_reports (
        url, page_title, meta_description, meta_keywords, 
        h1_tags, image_count, has_favicon, ai_feedback
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `)

		const result = stmt.run(
			report.url,
			report.page_title,
			report.meta_description,
			report.meta_keywords,
			report.h1_tags,
			report.image_count,
			report.has_favicon,
			report.ai_feedback
		)

		return result.lastInsertRowid
	},

	getReportById: (id: number): SeoReport | undefined => {
		const stmt = db.prepare('SELECT * FROM seo_reports WHERE id = ?')
		return stmt.get(id) as SeoReport | undefined
	},

	getAllReports: (limit = 50): SeoReport[] => {
		const stmt = db.prepare(`
      SELECT * FROM seo_reports 
      ORDER BY created_at DESC 
      LIMIT ?
    `)
		return stmt.all(limit) as SeoReport[]
	},

	getReportsByUrl: (url: string): SeoReport[] => {
		const stmt = db.prepare(`
      SELECT * FROM seo_reports 
      WHERE url = ? 
      ORDER BY created_at DESC
    `)
		return stmt.all(url) as SeoReport[]
	},

	deleteReport: (id: number) => {
		const stmt = db.prepare('DELETE FROM seo_reports WHERE id = ?')
		return stmt.run(id)
	}
}

export default db
===== src/lib/scraper.ts =====
import * as cheerio from 'cheerio'
import { z } from 'zod'

export interface PageMetadata {
	url: string
	pageTitle: string | null
	metaDescription: string | null
	metaKeywords: string | null
	h1Tags: string[]
	imageCount: number
	hasFavicon: boolean
	titleLength: number
	descriptionLength: number
}

const urlSchema = z.string().url()

export class ScraperError extends Error {
	constructor(
		message: string,
		public statusCode?: number
	) {
		super(message)
		this.name = 'ScraperError'
	}
}

export async function scrapeMetadata(url: string): Promise<PageMetadata> {
	try {
		urlSchema.parse(url)
	} catch (error) {
		throw new ScraperError('Invalid URL format')
	}

	const fullUrl = url.startsWith('http') ? url : `https://${url}`

	try {
		const controller = new AbortController()
		const timeout = setTimeout(() => controller.abort(), 10000)

		const response = await fetch(fullUrl, {
			signal: controller.signal,
			headers: {
				'User-Agent': 'Mozilla/5.0 (compatible; SEO-Report-Generator/1.0)'
			}
		})

		clearTimeout(timeout)

		if (!response.ok) {
			throw new ScraperError(
				`Failed to fetch URL: ${response.status} ${response.statusText}`,
				response.status
			)
		}

		const html = await response.text()
		const $ = cheerio.load(html)

		const pageTitle = $('title').first().text().trim() || null
		const metaDescription = $('meta[name="description"]').attr('content')?.trim() || null
		const metaKeywords = $('meta[name="keywords"]').attr('content')?.trim() || null

		const h1Tags: string[] = []
		$('h1').each((_, el) => {
			const text = $(el).text().trim()
			if (text) h1Tags.push(text)
		})

		const imageCount = $('img').length
		const hasFavicon = $('link[rel*="icon"]').length > 0

		const titleLength = pageTitle?.length || 0
		const descriptionLength = metaDescription?.length || 0

		return {
			url: fullUrl,
			pageTitle,
			metaDescription,
			metaKeywords,
			h1Tags,
			imageCount,
			hasFavicon,
			titleLength,
			descriptionLength
		}
	} catch (error) {
		if (error instanceof ScraperError) {
			throw error
		}

		if (error instanceof Error) {
			if (error.name === 'AbortError') {
				throw new ScraperError('Request timeout - the website took too long to respond')
			}
			throw new ScraperError(`Failed to scrape URL: ${error.message}`)
		}

		throw new ScraperError('An unknown error occurred while scraping')
	}
}

export function validateMetadata(metadata: PageMetadata): {
	issues: string[]
	warnings: string[]
} {
	const issues: string[] = []
	const warnings: string[] = []

	if (!metadata.pageTitle) {
		issues.push('Missing page title')
	} else {
		if (metadata.titleLength < 30) {
			warnings.push('Title is too short (recommended: 50-60 characters)')
		} else if (metadata.titleLength > 60) {
			warnings.push('Title is too long (recommended: 50-60 characters)')
		}
	}

	if (!metadata.metaDescription) {
		issues.push('Missing meta description')
	} else {
		if (metadata.descriptionLength < 120) {
			warnings.push('Meta description is too short (recommended: 150-160 characters)')
		} else if (metadata.descriptionLength > 160) {
			warnings.push('Meta description is too long (recommended: 150-160 characters)')
		}
	}

	if (metadata.h1Tags.length === 0) {
		issues.push('No H1 tags found')
	} else if (metadata.h1Tags.length > 1) {
		warnings.push(
			`Multiple H1 tags found (${metadata.h1Tags.length}). Best practice is one H1 per page.`
		)
	}

	if (!metadata.hasFavicon) {
		warnings.push('No favicon detected')
	}

	return { issues, warnings }
}
